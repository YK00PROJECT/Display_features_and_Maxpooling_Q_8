# -*- coding: utf-8 -*-
"""Display_features_and_Maxpooling_Q_8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M1s2dr-X7QsJ_MBmk_0XRObPz_qo2Tjv
"""

import tensorflow as tf
import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
import numpy as np
import PIL
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.models import Sequential
from tensorflow.keras import layers, models

from google.colab import drive
drive.mount('/content/drive')

img_height, img_width = 50, 50
batch_size = 32

train_ds = tf.keras.utils.image_dataset_from_directory(
  'drive/MyDrive/samecatanddog/',
  validation_split=0.2,
  subset="training",
  seed=123,
  image_size=(img_height, img_width),
  batch_size=batch_size)

val_ds = tf.keras.utils.image_dataset_from_directory(
  'drive/MyDrive/samecatanddog/',
  validation_split=0.2,
  subset="validation",
  seed=123,
  image_size=(img_height, img_width),
  batch_size=batch_size)

plt.figure(figsize=(10, 10))
for images, _ in train_ds.take(1):
    for i in range(9):
        ax = plt.subplot(3, 3, i + 1)
        plt.imshow(images[i].numpy().astype("uint8"))
        plt.axis("off")

num_classes = len(train_ds.class_names)

model = models.Sequential([
  layers.Rescaling(1./255, input_shape=(img_height, img_width, 3)),
  layers.Conv2D(16, 3, padding='valid', activation='relu'),
  layers.MaxPooling2D(),
  layers.Conv2D(8, 3, padding='valid', activation='relu'),
  layers.MaxPooling2D(),
  layers.Flatten(),
  layers.Dense(128, activation='relu'),
  layers.Dense(num_classes)
])

model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

history = model.fit(
  train_ds,
  validation_data=val_ds,
  epochs=10
)

import matplotlib.pyplot as plt

# Assuming feature_maps1 and feature_maps2 are obtained from the model
for layer_number in range(len(feature_maps1)):
    # Check the shape of the current layer's output
    layer_shape = feature_maps1[layer_number].shape
    print(f"Layer {layer_number} output shape: {layer_shape}")

    # Ensure the layer output is 4-dimensional
    if len(layer_shape) == 4 and layer_shape[-1] > 0:
        # Extract feature maps for the first and second image
        f1 = feature_maps1[layer_number][0, :, :, 0]  # Adjust the channel index as needed
        f2 = feature_maps2[layer_number][0, :, :, 0]  # Adjust the channel index as needed

        # Visualization of feature maps
        plt.figure(figsize=(12, 6))

        plt.subplot(1, 2, 1)
        plt.imshow(f1, cmap='gray')
        plt.title(f"Layer {layer_number} - Image 1")
        plt.axis('off')

        plt.subplot(1, 2, 2)
        plt.imshow(f2, cmap='gray')
        plt.title(f"Layer {layer_number} - Image 2")
        plt.axis('off')

        plt.show()

    else:
        print(f"Skipping layer {layer_number} for visualization due to incompatible shape.")